#!/bin/bash

# bin/dbsyncfromprod
# Sync database from production using Laravel artisan commands

# Configuration
PROD_HOST="guac"
PROD_PATH="~/mergelater.com/current"
BACKUP_DIR="storage/database/backups"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}üì¶ Starting database sync from production...${NC}"

# Safety check - prevent execution on production servers
HOSTNAME=$(hostname)
if [[ "$HOSTNAME" == *"forge"* ]] || [[ "$HOSTNAME" == *"guac"* ]] || [[ "$HOSTNAME" == *".mergelater.com"* ]] || [[ "$PWD" == *"/var/www/"* ]]; then
    echo -e "${RED}‚ùå SAFETY CHECK FAILED${NC}"
    echo "This script cannot be run on production servers!"
    echo "Current hostname: $HOSTNAME"
    echo "Current directory: $PWD"
    exit 1
fi

# Additional safety check - ensure we're in a development environment
if [ ! -f "compose.yaml" ] && [ ! -f "docker-compose.yml" ] && [ ! -f "compose.yml" ]; then
    echo -e "${RED}‚ùå SAFETY CHECK FAILED${NC}"
    echo "This script should only be run from a local development environment."
    echo "No compose file found in current directory."
    exit 1
fi

# Step 1: Test SSH connectivity
echo -e "${BLUE}üîç Testing SSH connectivity to production...${NC}"
if ! ssh "$PROD_HOST" "echo 'SSH connection test successful'" >/dev/null 2>&1; then
    echo -e "${RED}‚ùå SSH connection failed to $PROD_HOST${NC}"
    echo "Please check your SSH configuration and network connectivity."
    echo "Verify ~/.ssh/config settings for the production host."
    exit 1
fi
echo -e "${GREEN}‚úì SSH connectivity confirmed${NC}"

# Step 2: Test Laravel availability on production
echo -e "${BLUE}üîç Testing Laravel availability on production...${NC}"
LARAVEL_VERSION=$(ssh "$PROD_HOST" "cd $PROD_PATH && php artisan --version" 2>/dev/null)
if [ $? -ne 0 ] || [ -z "$LARAVEL_VERSION" ]; then
    echo -e "${RED}‚ùå Laravel not accessible on production server at $PROD_PATH${NC}"
    echo "Please ensure the Laravel application is properly deployed."
    exit 1
fi
echo -e "${GREEN}‚úì Laravel confirmed: $LARAVEL_VERSION${NC}"

# Step 3: Create backup on production server
echo -e "${BLUE}üíæ Creating fresh backup on production server...${NC}"
SSH_RESULT=$(ssh "$PROD_HOST" "cd $PROD_PATH && php artisan db:backup --format=custom --path=storage/database/backups" 2>&1)
if [ $? -ne 0 ]; then
    echo -e "${RED}‚ùå Failed to create backup on production server${NC}"
    echo "$SSH_RESULT"

    # Check for specific PostgreSQL issues and provide installation instructions
    if echo "$SSH_RESULT" | grep -q "server version mismatch"; then
        echo ""
        echo -e "${YELLOW}üîß PostgreSQL client version mismatch detected${NC}"
        echo "To fix this on Ubuntu/Debian production server, run:"
        echo ""
        echo "sudo sh -c 'echo \"deb http://apt.postgresql.org/pub/repos/apt \$(lsb_release -cs)-pgdg main\" > /etc/apt/sources.list.d/pgdg.list'"
        echo "curl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo gpg --dearmor -o /etc/apt/trusted.gpg.d/postgresql.gpg"
        echo "sudo apt update"
        echo "sudo apt install postgresql-client-17"
        echo ""
        echo "This installs PostgreSQL 17 client to match your database server version."
    elif echo "$SSH_RESULT" | grep -q "pg_dump.*not found"; then
        echo ""
        echo -e "${YELLOW}üîß PostgreSQL client not found on production server${NC}"
        echo "To install PostgreSQL client on Ubuntu/Debian production server, run:"
        echo ""
        echo "sudo sh -c 'echo \"deb http://apt.postgresql.org/pub/repos/apt \$(lsb_release -cs)-pgdg main\" > /etc/apt/sources.list.d/pgdg.list'"
        echo "curl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo gpg --dearmor -o /etc/apt/trusted.gpg.d/postgresql.gpg"
        echo "sudo apt update"
        echo "sudo apt install postgresql-client-17"
        echo ""
        echo "For other distributions:"
        echo "  CentOS/RHEL: sudo yum install postgresql17"
        echo "  macOS: brew install postgresql@17"
    fi

    exit 1
fi

# Step 4: Find the latest backup file
echo -e "${BLUE}üîç Finding latest backup file on production...${NC}"
LATEST_BACKUP=$(ssh "$PROD_HOST" "cd $PROD_PATH && ls -t storage/database/backups/backup-*.pgsql 2>/dev/null | head -n1" 2>/dev/null)
if [ -z "$LATEST_BACKUP" ]; then
    echo -e "${RED}‚ùå No backup file found on production server${NC}"
    exit 1
fi
echo -e "${GREEN}‚úì Latest backup: $LATEST_BACKUP${NC}"

# Step 5: Create local backup directory
mkdir -p "$BACKUP_DIR"

# Step 6: Compress backup on production for faster transfer
echo -e "${BLUE}üóúÔ∏è  Compressing backup file on production...${NC}"
COMPRESSED_BACKUP="${LATEST_BACKUP}.gz"
if ! ssh "$PROD_HOST" "cd $PROD_PATH && gzip -c '$LATEST_BACKUP' > '${COMPRESSED_BACKUP}'"; then
    echo -e "${RED}‚ùå Failed to compress backup file on production${NC}"
    exit 1
fi

# Get compressed file size for progress info
COMPRESSED_SIZE=$(ssh "$PROD_HOST" "stat -c%s '$PROD_PATH/${COMPRESSED_BACKUP}' 2>/dev/null || stat -f%z '$PROD_PATH/${COMPRESSED_BACKUP}' 2>/dev/null" 2>/dev/null)
if [ -n "$COMPRESSED_SIZE" ]; then
    echo -e "${GREEN}‚úì Compressed to $(numfmt --to=iec $COMPRESSED_SIZE 2>/dev/null || echo "${COMPRESSED_SIZE} bytes")${NC}"
fi

# Step 7: Download compressed backup file from production
echo -e "${BLUE}üì• Downloading compressed backup from production...${NC}"
LOCAL_COMPRESSED_FILE="$BACKUP_DIR/$(basename "$COMPRESSED_BACKUP")"
if ! scp "$PROD_HOST:$PROD_PATH/$COMPRESSED_BACKUP" "$LOCAL_COMPRESSED_FILE"; then
    echo -e "${RED}‚ùå Failed to download compressed backup file from production${NC}"
    # Clean up remote compressed file
    ssh "$PROD_HOST" "rm -f '$PROD_PATH/$COMPRESSED_BACKUP'" >/dev/null 2>&1
    exit 1
fi

# Step 8: Decompress locally
echo -e "${BLUE}üì¶ Decompressing backup file locally...${NC}"
LOCAL_BACKUP_FILE="$BACKUP_DIR/$(basename "$LATEST_BACKUP")"
if ! gunzip -c "$LOCAL_COMPRESSED_FILE" > "$LOCAL_BACKUP_FILE"; then
    echo -e "${RED}‚ùå Failed to decompress backup file${NC}"
    rm -f "$LOCAL_COMPRESSED_FILE"
    exit 1
fi

# Clean up compressed file locally
rm -f "$LOCAL_COMPRESSED_FILE"

# Verify decompressed file has content
if [ ! -f "$LOCAL_BACKUP_FILE" ] || [ $(stat -f%z "$LOCAL_BACKUP_FILE" 2>/dev/null || stat -c%s "$LOCAL_BACKUP_FILE" 2>/dev/null) -lt 1024 ]; then
    echo -e "${RED}‚ùå Decompressed backup file is missing or too small${NC}"
    exit 1
fi

LOCAL_SIZE=$(stat -f%z "$LOCAL_BACKUP_FILE" 2>/dev/null || stat -c%s "$LOCAL_BACKUP_FILE" 2>/dev/null)
echo -e "${GREEN}‚úì Backup ready: $LOCAL_BACKUP_FILE ($(numfmt --to=iec $LOCAL_SIZE 2>/dev/null || echo "${LOCAL_SIZE} bytes"))${NC}"

# Step 7: Restore database locally using Laravel artisan command
echo -e "${BLUE}üîÑ Restoring database locally...${NC}"
./bin/artisan db:restore "$LOCAL_BACKUP_FILE"
RESTORE_RESULT=$?

# Step 9: Cleanup
echo -e "${BLUE}üßΩ Cleaning up temporary files...${NC}"

# Remove both backup and compressed files from production server
ssh "$PROD_HOST" "rm -f '$PROD_PATH/$LATEST_BACKUP' '$PROD_PATH/${COMPRESSED_BACKUP}'" >/dev/null 2>&1

# Remove local backup file unless --keep-backup flag is passed
if [[ "$*" != *"--keep-backup"* ]]; then
    rm -f "$LOCAL_BACKUP_FILE"
    echo -e "${GREEN}‚úì Temporary backup file removed${NC}"
else
    echo -e "${GREEN}‚úì Backup file kept at: $LOCAL_BACKUP_FILE${NC}"
fi

# Final result
if [ $RESTORE_RESULT -eq 0 ]; then
    echo ""
    echo -e "${GREEN}‚úÖ Database sync completed successfully!${NC}"
    echo -e "${GREEN}üéâ Your local development database now contains fresh production data.${NC}"
else
    echo -e "${RED}‚ùå Database restoration failed${NC}"
    exit 1
fi
